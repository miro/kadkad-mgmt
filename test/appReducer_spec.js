// Tests for appReducer, using actions generated by appActions.
// NOTE: renaming imageEditView will make all the expect-objects invalid

import {List, Map, fromJS, toJS} from 'immutable';
import {expect} from 'chai';

import {default as appReducer, defaultState} from '../src/reducers/appReducer';
import * as actions from '../src/actions/appActions';


const initialState = fromJS(defaultState);


// # Paging related tests -------------------------------------------
//
const VIEW_NAME = 'imageEditView'; // use the imageEditView on the paging tests
const ITEMS_PER_PAGE = defaultState.paging[VIEW_NAME].itemsInPage;

describe('appReducer', () => {
  it('handles basic TURN_PAGE to forward', () => {
    const totalItemsInThisTest = ITEMS_PER_PAGE * 2;
    const action = actions.turnPage(VIEW_NAME, true, totalItemsInThisTest);

    const nextState = appReducer(initialState, action);
    expect(nextState).to.equal(fromJS({
      paging: {
        imageEditView: {
          itemsInPage: ITEMS_PER_PAGE,
          currentPage: 1
        }
      }
    }));
  });


  it('handles basic TURN_PAGE to forward and back', () => {
    const totalItemsInThisTest = ITEMS_PER_PAGE * 2;

    // first action
    const turnSecondPage = actions.turnPage(VIEW_NAME, true, totalItemsInThisTest);
    const secondState = appReducer(initialState, turnSecondPage);
    expect(secondState).to.equal(fromJS({
      paging: {
        imageEditView: {
          itemsInPage: ITEMS_PER_PAGE,
          currentPage: 1
        }
      }
    }));

    // second action
    const turnBackToFirstPage = actions.turnPage(VIEW_NAME, false, totalItemsInThisTest);
    const thirdState = appReducer(secondState, turnBackToFirstPage);
    expect(thirdState).to.equal(fromJS({
      paging: {
        imageEditView: {
          itemsInPage: ITEMS_PER_PAGE,
          currentPage: 0
        }
      }
    }));
  });


  it('does not let TURN_PAGE to overflow', () => {
    const totalItemsInThisTest = ITEMS_PER_PAGE - 1;

    const action = actions.turnPage(VIEW_NAME, true, totalItemsInThisTest);

    const nextState = appReducer(initialState, action);
    expect(nextState).to.equal(fromJS({
      paging: {
        imageEditView: {
          itemsInPage: ITEMS_PER_PAGE,
          currentPage: 0
        }
      }
    }));
  });


  it('does not let TURN_PAGE to overflow when there is only one item', () => {
    const totalItemsInThisTest = 1;

    const action = actions.turnPage(VIEW_NAME, true, totalItemsInThisTest);

    const nextState = appReducer(initialState, action);
    expect(nextState).to.equal(fromJS({
      paging: {
        imageEditView: {
          itemsInPage: ITEMS_PER_PAGE,
          currentPage: 0
        }
      }
    }));
  });


  it('does not let TURN_PAGE to underflow', () => {
    // is "underflow" even a term?
    const tryToTurnToNegativePage = actions.turnPage(VIEW_NAME, false, 10);

    const nextState = appReducer(initialState, tryToTurnToNegativePage);
    expect(nextState).to.equal(fromJS({
      paging: {
        imageEditView: {
          itemsInPage: ITEMS_PER_PAGE,
          currentPage: 0
        }
      }
    }));
  });

  it('TURN_PAGE shows second page containing only one item', () => {
    const totalItemsInThisTest = ITEMS_PER_PAGE + 1;
    const turnNextPage = actions.turnPage(VIEW_NAME, true, totalItemsInThisTest);
    const nextState = appReducer(initialState, turnNextPage);
    expect(nextState).to.equal(fromJS({
      paging: {
        imageEditView: {
          itemsInPage: ITEMS_PER_PAGE,
          currentPage: 1
        }
      }
    }));
  });
});
