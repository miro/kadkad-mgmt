// Tests for appReducer, using actions generated by appActions.
// NOTE: renaming imageEditView will make all the expect-objects invalid

import {List, Map, fromJS, toJS} from 'immutable';
import {expect} from 'chai';

import {default as appReducer, defaultState} from '../src/reducers/appReducer';
import * as actions from '../src/actions/appActions';


const initialState = fromJS(defaultState);

// # Tab related tests ---------------------------------------------
const TAB_VIEW_NAME = 'spotsAndPersonsEditView';
const TABS = 'tabs'; // shortcut
const DEFAULT_OPEN_TAB = defaultState[TABS][TAB_VIEW_NAME].currentTab;

describe('appReducer (tabs)', () => {
  it('handles basic TAB_CHANGE', () => {
    const action = actions.changeTab(TAB_VIEW_NAME, 'persons');
    const nextState = appReducer(initialState, action);
    expect(nextState.getIn(['tabs', TAB_VIEW_NAME, 'currentTab'])).to.equal('persons');
  });

  it('does not change anything if target tab does not exist', () => {
    const action = actions.changeTab(TAB_VIEW_NAME, 'unexistent');
    const nextState = appReducer(initialState, action);
    expect(nextState.getIn(['tabs', TAB_VIEW_NAME, 'currentTab'])).to.equal(DEFAULT_OPEN_TAB);
  });
});


// # User account tests --------------------------------------------
describe('appReducer (user)', () => {
  it('handles basic USER_UPDATE', () => {
    const action = {
      type: 'USER_UPDATE',
      profile: { name: 'foo' },
      loggedIn: true
    };
    const nextState = appReducer(initialState, action);
    expect(nextState.get('user')).to.equal(fromJS({
      profile: { name: 'foo' },
      loggedIn: true
    }));
  });

  it('handles setting & unsetting of user via USER_UPDATE', () => {
    const loginAction = {
      type: 'USER_UPDATE',
      profile: { name: 'foo' },
      loggedIn: true
    };
    const loggedInState = appReducer(initialState, loginAction);
    expect(loggedInState.get('user')).to.equal(fromJS({
      profile: { name: 'foo' },
      loggedIn: true
    }));

    const logoutAction = {
      type: 'USER_UPDATE',
      profile: {},
      loggedIn: false
    };
    const loggedOutState = appReducer(initialState, logoutAction);
    expect(loggedOutState.get('user')).to.equal(fromJS({
      profile: {},
      loggedIn: false
    }));
  });
});


// # Paging related tests -------------------------------------------
//
const VIEW_NAME = 'imageEditView'; // use the imageEditView on the paging tests
const ITEMS_PER_PAGE = defaultState.paging[VIEW_NAME].itemsInPage;
const PAGING = 'paging'; // property where the paging data is saved in the state

describe('appReducer (paging)', () => {
  it('handles basic PAGE_TURN to forward', () => {
    const totalItemsInThisTest = ITEMS_PER_PAGE * 2;
    const action = actions.turnPage(VIEW_NAME, true, totalItemsInThisTest);

    const nextState = appReducer(initialState, action);
    expect(nextState.get(PAGING)).to.equal(fromJS({
      imageEditView: {
        itemsInPage: ITEMS_PER_PAGE,
        currentPage: 1
      }
    }));
  });


  it('handles basic PAGE_TURN to forward and back', () => {
    const totalItemsInThisTest = ITEMS_PER_PAGE * 2;

    // first action
    const turnSecondPage = actions.turnPage(VIEW_NAME, true, totalItemsInThisTest);
    const secondState = appReducer(initialState, turnSecondPage);
    expect(secondState.get(PAGING)).to.equal(fromJS({
      imageEditView: {
        itemsInPage: ITEMS_PER_PAGE,
        currentPage: 1
      }
    }));

    // second action
    const turnBackToFirstPage = actions.turnPage(VIEW_NAME, false, totalItemsInThisTest);
    const thirdState = appReducer(secondState, turnBackToFirstPage);
    expect(thirdState.get(PAGING)).to.equal(fromJS({
      imageEditView: {
        itemsInPage: ITEMS_PER_PAGE,
        currentPage: 0
      }
    }));
  });


  it('does not let PAGE_TURN to overflow', () => {
    const totalItemsInThisTest = ITEMS_PER_PAGE - 1;

    const action = actions.turnPage(VIEW_NAME, true, totalItemsInThisTest);

    const nextState = appReducer(initialState, action);
    expect(nextState.get(PAGING)).to.equal(fromJS({
      imageEditView: {
        itemsInPage: ITEMS_PER_PAGE,
        currentPage: 0
      }
    }));
  });


  it('does not let PAGE_TURN to overflow when there is only one item', () => {
    const totalItemsInThisTest = 1;

    const action = actions.turnPage(VIEW_NAME, true, totalItemsInThisTest);

    const nextState = appReducer(initialState, action);
    expect(nextState.get(PAGING)).to.equal(fromJS({
      imageEditView: {
        itemsInPage: ITEMS_PER_PAGE,
        currentPage: 0
      }
    }));
  });


  it('does not let PAGE_TURN to underflow', () => {
    // is "underflow" even a term?
    const tryToTurnToNegativePage = actions.turnPage(VIEW_NAME, false, 10);

    const nextState = appReducer(initialState, tryToTurnToNegativePage);
    expect(nextState.get(PAGING)).to.equal(fromJS({
      imageEditView: {
        itemsInPage: ITEMS_PER_PAGE,
        currentPage: 0
      }
    }));
  });

  it('PAGE_TURN shows second page containing only one item', () => {
    const totalItemsInThisTest = ITEMS_PER_PAGE + 1;
    const turnNextPage = actions.turnPage(VIEW_NAME, true, totalItemsInThisTest);
    const nextState = appReducer(initialState, turnNextPage);
    expect(nextState.get(PAGING)).to.equal(fromJS({
      imageEditView: {
        itemsInPage: ITEMS_PER_PAGE,
        currentPage: 1
      }
    }));
  });
});
